# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1emSmzQOjP-6br79FnyAx6I1fB1wS7Su1
"""
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.cluster import KMeans, DBSCAN, AgglomerativeClustering

# Load dataset
@st.cache_data
def load_data():
    data = pd.read_excel('marketing_campaign1.xlsx')
    return data.copy()

data = load_data()

# Preprocess non-numeric columns for clustering (encoding if needed)
@st.cache_data
def preprocess_data(data):
    processed_data = data.copy()
    # Encode non-numeric columns
    label_encoders = {}
    for column in processed_data.select_dtypes(include=['object']).columns:
        le = LabelEncoder()
        processed_data[column] = le.fit_transform(processed_data[column].astype(str))
        label_encoders[column] = le
    return processed_data, label_encoders

processed_data, label_encoders = preprocess_data(data)

# Title
st.title("Customer Personality Analysis and Segmentation")
st.markdown("Analyze customer data to uncover patterns and create actionable insights.")

# Tabs for EDA and Clustering
tab1, tab2 = st.tabs(["ðŸ“Š EDA", "ðŸ”— Clustering"])

# EDA Tab
with tab1:
    st.subheader("Exploratory Data Analysis (EDA)")
    st.markdown("Explore the dataset and visualize key trends.")

    # Display raw data
    if st.checkbox("Show Raw Data"):
        st.write(data)

    # Age Distribution
    if st.checkbox("Show Age Distribution"):
        data['Age'] = 2025 - data['Year_Birth']
        fig, ax = plt.subplots(figsize=(8, 5))
        ax.hist(data['Age'], bins=20, color='skyblue', edgecolor='black')
        ax.set_title("Age Distribution of Customers")
        ax.set_xlabel("Age")
        ax.set_ylabel("Frequency")
        st.pyplot(fig)

    # Spending Distribution
    spending_columns = [
        'MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts',
        'MntSweetProducts', 'MntGoldProds'
    ]
    if st.checkbox("Show Spending Distribution"):
        total_spending = data[spending_columns].sum()
        fig, ax = plt.subplots(figsize=(8, 5))
        total_spending.plot(kind='bar', ax=ax, color='orange', edgecolor='black')
        ax.set_title("Total Spending on Product Categories")
        ax.set_xlabel("Product Category")
        ax.set_ylabel("Total Spending")
        st.pyplot(fig)

    # Correlation Heatmap
    if st.checkbox("Show Correlation Heatmap"):
        # Select only relevant numeric columns
        relevant_columns = [
            'Income', 'Recency', 'MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts',
            'MntSweetProducts', 'MntGoldProds', 'NumDealsPurchases', 'NumWebPurchases',
            'NumCatalogPurchases', 'NumStorePurchases', 'NumWebVisitsMonth', 'Response'
        ]
        numeric_data = data[relevant_columns].dropna()

        if numeric_data.empty:
            st.error("No numeric data available for correlation.")
        else:
            # Calculate correlation matrix
            corr = numeric_data.corr()
            
            # Plot heatmap
            fig, ax = plt.subplots(figsize=(12, 10))  # Increase figure size for readability
            sns.heatmap(corr, annot=True, fmt=".2f", cmap="RdBu", cbar=True, ax=ax, vmin=-1, vmax=1)
            ax.set_title("Correlation Heatmap (Filtered)")
            st.pyplot(fig)

# Clustering Tab
with tab2:
    st.subheader("Clustering Analysis")
    st.markdown("Group customers based on similar traits and behaviors.")

    # Feature Selection
    selected_features = st.multiselect(
        "Select Features for Clustering",
        options=processed_data.columns.tolist(),
        default=['MntWines', 'MntFruits', 'MntMeatProducts', 'MntFishProducts'],
        help="Choose features for clustering."
    )

    if selected_features:
        # Filter selected numeric features
        numeric_features = processed_data[selected_features]

        if numeric_features.empty:
            st.error("Please select at least one numeric feature for clustering.")
        else:
            # Handle missing values by filling them with the column mean
            numeric_features = numeric_features.fillna(numeric_features.mean())
            
            # Standardize the data
            scaler = StandardScaler()
            scaled_features = scaler.fit_transform(numeric_features)

            # Choose clustering algorithm
            clustering_method = st.radio(
                "Select Clustering Algorithm",
                ["KMeans", "DBSCAN", "Hierarchical Agglomerative Clustering"],
                help="Choose the clustering method you'd like to apply."
            )

            if clustering_method == "KMeans":
                n_clusters = st.slider("Number of Clusters", 2, 10, 3)
                kmeans = KMeans(n_clusters=n_clusters, random_state=42)
                processed_data['Cluster'] = kmeans.fit_predict(scaled_features)
                st.success(f"KMeans clustering completed with {n_clusters} clusters.")

            elif clustering_method == "DBSCAN":
                eps = st.slider("Epsilon (eps)", 0.1, 5.0, 0.5, step=0.1)
                min_samples = st.slider("Minimum Samples", 1, 10, 5)
                dbscan = DBSCAN(eps=eps, min_samples=min_samples)
                try:
                    processed_data['Cluster'] = dbscan.fit_predict(scaled_features)
                    st.success("DBSCAN clustering completed.")
                except ValueError as e:
                    st.error(f"DBSCAN failed: {str(e)}")

            elif clustering_method == "Hierarchical Agglomerative Clustering":
                n_clusters = st.slider("Number of Clusters", 2, 10, 3)
                linkage = st.selectbox("Linkage Type", ["ward", "complete", "average", "single"])
                agglo = AgglomerativeClustering(n_clusters=n_clusters, linkage=linkage)
                processed_data['Cluster'] = agglo.fit_predict(scaled_features)
                st.success(f"Hierarchical Agglomerative Clustering completed with {n_clusters} clusters.")

            # Visualize Clusters
            if "Cluster" in processed_data.columns:
                st.markdown("### Cluster Visualization")
                fig, ax = plt.subplots(figsize=(8, 5))
                plt.scatter(scaled_features[:, 0], scaled_features[:, 1], c=processed_data['Cluster'], cmap='viridis', s=50, alpha=0.7)
                plt.title(f"Clusters Visualization ({clustering_method})")
                plt.xlabel("Feature 1")
                plt.ylabel("Feature 2")
                st.pyplot(fig)

